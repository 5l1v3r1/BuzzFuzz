#!/usr/bin/env python2
## -*- coding: utf-8 -*-

# Assumptions: we've already used taint analysis to determine there's a 
#              user-controllable indirect call site, now we're using 
#              symbex to figure out how to control it

import sys
import triton
import pintool

taintedIns = 0x400868  # Found in a previous DTA pass
target     = 0x0  # Target to redirect callsite to
taintSrcIns=[0x4007d0,0x4007eb,0x400809,0x400824]

Triton = pintool.getTritonContext()

#def symbolize_taintSrc(insn):
    

def exploit_mmap(insn, op):
    regId   = Triton.getSymbolicRegisterId(op)
    regExpr = Triton.unrollAst(Triton.getAstFromId(regId))
    ast = Triton.getAstContext()
    exploitExpr = ast.bvslt(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))
    print(Triton.getSymbolicVariables())
    #i=0
    #while str(Triton.getAstFromId(i))!=None:
    #    if 'SymVar' in str(Triton.getAstFromId(i)):
    #print(Triton.getAstFromId(10000))
    #    i=i+1 

    #for k, v in Triton.getSymbolicVariables().iteritems():
     #   taintedByteExpr = Triton.getAstFromId(k)
        
      #  print(k,v,taintedByteExpr)
        
      #  if 'taintedByteaa' in v.getComment():
            # Argument characters must be printable
      #      taintedByteExpr = Triton.getAstFromId(k)
      #      print(taintedByteExpr,k)
      #      taintedByteExpr = ast.land([
      #                    ast.bvuge(taintedByteExpr, ast.bv(0,  triton.CPUSIZE.QWORD_BIT)),
      #                    ast.bvule(taintedByteExpr, ast.bv(255, triton.CPUSIZE.QWORD_BIT))
      #                ])
      #      exploitExpr = ast.land([exploitExpr, taintedByteExpr])

    print 'Getting model for %s -> small than 0x%x' % (insn, target)
    model = Triton.getModel(exploitExpr)
    for k, v in model.iteritems():
        print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())

def hook_taintedByte(insn):
    if insn.getAddress() in taintSrcIns:
        for op in insn.getOperands():
            
            if op.getType() == triton.OPERAND.MEM:
                addr = op.getAddress()
                c = pintool.getCurrentMemoryValue(addr)
               
                Triton.setConcreteMemoryValue(addr, c)
                Triton.convertMemoryToSymbolicVariable(
                        triton.MemoryAccess(addr,triton.CPUSIZE.BYTE)
                    ).setComment('taintedByte '+str(addr)+' : '+str(c))
           
                print('Symbolized taintedByte '+str(addr)+' : '+str(c))

#def hook_mmap(insn):
    flag=0
    if insn.getAddress() == taintedIns:
        for op in insn.getOperands():
            if flag==1 and op.getType() == triton.OPERAND.REG:
                print 'Found Target Ins \'%s\'' % (insn)
                exploit_mmap(insn, op)
            flag=1    

def main():
    Triton.setArchitecture(triton.ARCH.X86_64)
    Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)

    pintool.startAnalysisFromSymbol('main')

    pintool.insertCall(hook_taintedByte, pintool.INSERT_POINT.BEFORE)
    #pintool.insertCall(hook_mmap, pintool.INSERT_POINT.AFTER)

    pintool.runProgram()

if __name__ == '__main__':
    main()

